<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title><title><no title></title></title>
  <meta http-equiv="content-type" content="text/html; charset=None">
  <link rel="stylesheet" href="..\..\_static\pygments.css" type="text/css">
</head>
<body>
<h2><title><no title></title></h2>

<div class="highlight"><pre><span></span><span class="cm">/*!</span>
<span class="cm"> * jQuery Internationalization library</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011-2013 Santhosh Thottingal, Neil Kandalgaonkar</span>
<span class="cm"> *</span>
<span class="cm"> * jquery.i18n is dual licensed GPLv2 or later and MIT. You don&#39;t have to do</span>
<span class="cm"> * anything special to choose one license or the other and you don&#39;t have to</span>
<span class="cm"> * notify anyone which license you are using. You are free to use</span>
<span class="cm"> * UniversalLanguageSelector in commercial projects as long as the copyright</span>
<span class="cm"> * header is left intact. See files GPL-LICENSE and MIT-LICENSE for details.</span>
<span class="cm"> *</span>
<span class="cm"> * @licence GNU General Public Licence 2.0 or later</span>
<span class="cm"> * @licence MIT License</span>
<span class="cm"> */</span>

<span class="p">(</span> <span class="kd">function</span> <span class="p">(</span> <span class="nx">$</span> <span class="p">)</span> <span class="p">{</span>
	<span class="s1">&#39;use strict&#39;</span><span class="p">;</span>

	<span class="kd">var</span> <span class="nx">MessageParser</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span> <span class="nx">options</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span> <span class="p">{},</span> <span class="nx">$</span><span class="p">.</span><span class="nx">i18n</span><span class="p">.</span><span class="nx">parser</span><span class="p">.</span><span class="nx">defaults</span><span class="p">,</span> <span class="nx">options</span> <span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="nx">language</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">i18n</span><span class="p">.</span><span class="nx">languages</span><span class="p">[</span> <span class="nb">String</span><span class="p">.</span><span class="nx">locale</span> <span class="p">]</span> <span class="o">||</span> <span class="nx">$</span><span class="p">.</span><span class="nx">i18n</span><span class="p">.</span><span class="nx">languages</span><span class="p">[</span> <span class="s1">&#39;default&#39;</span> <span class="p">];</span>
		<span class="k">this</span><span class="p">.</span><span class="nx">emitter</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">i18n</span><span class="p">.</span><span class="nx">parser</span><span class="p">.</span><span class="nx">emitter</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="nx">MessageParser</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>

		<span class="nx">constructor</span><span class="o">:</span> <span class="nx">MessageParser</span><span class="p">,</span>

		<span class="nx">simpleParse</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">parameters</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">message</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span> <span class="sr">/\$(\d+)/g</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">match</span> <span class="p">)</span> <span class="p">{</span>
				<span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span> <span class="nx">match</span><span class="p">,</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

				<span class="k">return</span> <span class="nx">parameters</span><span class="p">[</span> <span class="nx">index</span> <span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">parameters</span><span class="p">[</span> <span class="nx">index</span> <span class="p">]</span> <span class="o">:</span> <span class="s1">&#39;$&#39;</span> <span class="o">+</span> <span class="nx">match</span><span class="p">;</span>
			<span class="p">}</span> <span class="p">);</span>
		<span class="p">},</span>

		<span class="nx">parse</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">replacements</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="nx">message</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span> <span class="s1">&#39;</span><span class="cp">{{</span><span class="s1">&#39; ) &lt; 0 ) {</span>
<span class="s1">				return this.simpleParse( message, replacements );</span>
<span class="s1">			}</span>

<span class="s1">			this.emitter.language = $.i18n.languages[ $.i18n().locale ] ||</span>
<span class="s1">				$.i18n.languages[ &#39;</span><span class="nv">default</span><span class="s1">&#39; ];</span>

<span class="s1">			return this.emitter.emit( this.ast( message ), replacements );</span>
<span class="s1">		},</span>

<span class="s1">		ast: function ( message ) {</span>
<span class="s1">			var pipe, colon, backslash, anyCharacter, dollar, digits, regularLiteral,</span>
<span class="s1">				regularLiteralWithoutBar, regularLiteralWithoutSpace, escapedOrLiteralWithoutBar,</span>
<span class="s1">				escapedOrRegularLiteral, templateContents, templateName, openTemplate,</span>
<span class="s1">				closeTemplate, expression, paramExpression, result,</span>
<span class="s1">				pos = 0;</span>

<span class="s1">			// Try parsers until one works, if none work return null</span>
<span class="s1">			function choice( parserSyntax ) {</span>
<span class="s1">				return function () {</span>
<span class="s1">					var i, result;</span>

<span class="s1">					for ( i = 0; i &lt; parserSyntax.length; i++ ) {</span>
<span class="s1">						result = parserSyntax[ i ]();</span>

<span class="s1">						if ( result !== null ) {</span>
<span class="s1">							return result;</span>
<span class="s1">						}</span>
<span class="s1">					}</span>

<span class="s1">					return null;</span>
<span class="s1">				};</span>
<span class="s1">			}</span>

<span class="s1">			// Try several parserSyntax-es in a row.</span>
<span class="s1">			// All must succeed; otherwise, return null.</span>
<span class="s1">			// This is the only eager one.</span>
<span class="s1">			function sequence( parserSyntax ) {</span>
<span class="s1">				var i, res,</span>
<span class="s1">					originalPos = pos,</span>
<span class="s1">					result = [];</span>

<span class="s1">				for ( i = 0; i &lt; parserSyntax.length; i++ ) {</span>
<span class="s1">					res = parserSyntax[ i ]();</span>

<span class="s1">					if ( res === null ) {</span>
<span class="s1">						pos = originalPos;</span>

<span class="s1">						return null;</span>
<span class="s1">					}</span>

<span class="s1">					result.push( res );</span>
<span class="s1">				}</span>

<span class="s1">				return result;</span>
<span class="s1">			}</span>

<span class="s1">			// Run the same parser over and over until it fails.</span>
<span class="s1">			// Must succeed a minimum of n times; otherwise, return null.</span>
<span class="s1">			function nOrMore( n, p ) {</span>
<span class="s1">				return function () {</span>
<span class="s1">					var originalPos = pos,</span>
<span class="s1">						result = [],</span>
<span class="s1">						parsed = p();</span>

<span class="s1">					while ( parsed !== null ) {</span>
<span class="s1">						result.push( parsed );</span>
<span class="s1">						parsed = p();</span>
<span class="s1">					}</span>

<span class="s1">					if ( result.length &lt; n ) {</span>
<span class="s1">						pos = originalPos;</span>

<span class="s1">						return null;</span>
<span class="s1">					}</span>

<span class="s1">					return result;</span>
<span class="s1">				};</span>
<span class="s1">			}</span>

<span class="s1">			// Helpers -- just make parserSyntax out of simpler JS builtin types</span>

<span class="s1">			function makeStringParser( s ) {</span>
<span class="s1">				var len = s.length;</span>

<span class="s1">				return function () {</span>
<span class="s1">					var result = null;</span>

<span class="s1">					if ( message.slice( pos, pos + len ) === s ) {</span>
<span class="s1">						result = s;</span>
<span class="s1">						pos += len;</span>
<span class="s1">					}</span>

<span class="s1">					return result;</span>
<span class="s1">				};</span>
<span class="s1">			}</span>

<span class="s1">			function makeRegexParser( regex ) {</span>
<span class="s1">				return function () {</span>
<span class="s1">					var matches = message.slice( pos ).match( regex );</span>

<span class="s1">					if ( matches === null ) {</span>
<span class="s1">						return null;</span>
<span class="s1">					}</span>

<span class="s1">					pos += matches[ 0 ].length;</span>

<span class="s1">					return matches[ 0 ];</span>
<span class="s1">				};</span>
<span class="s1">			}</span>

<span class="s1">			pipe = makeStringParser( &#39;</span><span class="err">|</span><span class="s1">&#39; );</span>
<span class="s1">			colon = makeStringParser( &#39;:&#39; );</span>
<span class="s1">			backslash = makeStringParser( &#39;</span><span class="err">\\</span><span class="s1">&#39; );</span>
<span class="s1">			anyCharacter = makeRegexParser( /^./ );</span>
<span class="s1">			dollar = makeStringParser( &#39;</span><span class="err">$</span><span class="s1">&#39; );</span>
<span class="s1">			digits = makeRegexParser( /^\d+/ );</span>
<span class="s1">			regularLiteral = makeRegexParser( /^[^{}[\]$\\]/ );</span>
<span class="s1">			regularLiteralWithoutBar = makeRegexParser( /^[^{}[\]$\\|]/ );</span>
<span class="s1">			regularLiteralWithoutSpace = makeRegexParser( /^[^{}[\]$\s]/ );</span>

<span class="s1">			// There is a general pattern:</span>
<span class="s1">			// parse a thing;</span>
<span class="s1">			// if it worked, apply transform,</span>
<span class="s1">			// otherwise return null.</span>
<span class="s1">			// But using this as a combinator seems to cause problems</span>
<span class="s1">			// when combined with nOrMore().</span>
<span class="s1">			// May be some scoping issue.</span>
<span class="s1">			function transform( p, fn ) {</span>
<span class="s1">				return function () {</span>
<span class="s1">					var result = p();</span>

<span class="s1">					return result === null ? null : fn( result );</span>
<span class="s1">				};</span>
<span class="s1">			}</span>

<span class="s1">			// Used to define &quot;literals&quot; within template parameters. The pipe</span>
<span class="s1">			// character is the parameter delimeter, so by default</span>
<span class="s1">			// it is not a literal in the parameter</span>
<span class="s1">			function literalWithoutBar() {</span>
<span class="s1">				var result = nOrMore( 1, escapedOrLiteralWithoutBar )();</span>

<span class="s1">				return result === null ? null : result.join( &#39;&#39; );</span>
<span class="s1">			}</span>

<span class="s1">			function literal() {</span>
<span class="s1">				var result = nOrMore( 1, escapedOrRegularLiteral )();</span>

<span class="s1">				return result === null ? null : result.join( &#39;&#39; );</span>
<span class="s1">			}</span>

<span class="s1">			function escapedLiteral() {</span>
<span class="s1">				var result = sequence( [ backslash, anyCharacter ] );</span>

<span class="s1">				return result === null ? null : result[ 1 ];</span>
<span class="s1">			}</span>

<span class="s1">			choice( [ escapedLiteral, regularLiteralWithoutSpace ] );</span>
<span class="s1">			escapedOrLiteralWithoutBar = choice( [ escapedLiteral, regularLiteralWithoutBar ] );</span>
<span class="s1">			escapedOrRegularLiteral = choice( [ escapedLiteral, regularLiteral ] );</span>

<span class="s1">			function replacement() {</span>
<span class="s1">				var result = sequence( [ dollar, digits ] );</span>

<span class="s1">				if ( result === null ) {</span>
<span class="s1">					return null;</span>
<span class="s1">				}</span>

<span class="s1">				return [ &#39;</span><span class="nv">REPLACE</span><span class="s1">&#39;, parseInt( result[ 1 ], 10 ) - 1 ];</span>
<span class="s1">			}</span>

<span class="s1">			templateName = transform(</span>
<span class="s1">				// see $wgLegalTitleChars</span>
<span class="s1">				// not allowing : due to the need to catch &quot;PLURAL:$1&quot;</span>
<span class="s1">				makeRegexParser( /^[ !&quot;$&amp;&#39;</span><span class="o">()*,</span><span class="err">.</span><span class="o">/</span><span class="m">0</span><span class="o">-</span><span class="m">9</span><span class="err">;</span><span class="o">=</span><span class="err">?@</span><span class="nv">A-Z</span><span class="err">^</span><span class="kp">_</span><span class="err">`</span><span class="nv">a-z</span><span class="o">~</span><span class="err">\</span><span class="nv">x80-</span><span class="err">\</span><span class="nv">xFF</span><span class="o">+-]+/</span> <span class="o">),</span>

				<span class="nv">function</span> <span class="o">(</span> <span class="nv">result</span> <span class="o">)</span> <span class="o">{</span>
					<span class="nv">return</span> <span class="nv">result.toString</span><span class="o">()</span><span class="err">;</span>
				<span class="o">}</span>
			<span class="o">)</span><span class="err">;</span>

			<span class="nv">function</span> <span class="nv">templateParam</span><span class="o">()</span> <span class="o">{</span>
				<span class="nv">var</span> <span class="nv">expr</span><span class="o">,</span>
					<span class="nv">result</span> <span class="o">=</span> <span class="nv">sequence</span><span class="o">(</span> <span class="o">[</span> <span class="nv">pipe</span><span class="o">,</span> <span class="nv">nOrMore</span><span class="o">(</span> <span class="m">0</span><span class="o">,</span> <span class="nv">paramExpression</span> <span class="o">)</span> <span class="o">]</span> <span class="o">)</span><span class="err">;</span>

				<span class="k">if</span> <span class="o">(</span> <span class="nv">result</span> <span class="o">===</span> <span class="nv">null</span> <span class="o">)</span> <span class="o">{</span>
					<span class="nv">return</span> <span class="nv">null</span><span class="err">;</span>
				<span class="o">}</span>

				<span class="nv">expr</span> <span class="o">=</span> <span class="nv">result</span><span class="o">[</span> <span class="m">1</span> <span class="o">]</span><span class="err">;</span>

				<span class="o">//</span> <span class="nv">use</span> <span class="nv">a</span> <span class="s2">&quot;CONCAT&quot;</span> <span class="nv">operator</span> <span class="k">if</span> <span class="nv">there</span> <span class="nv">are</span> <span class="nv">multiple</span> <span class="nv">nodes</span><span class="o">,</span>
				<span class="o">//</span> <span class="nv">otherwise</span> <span class="nv">return</span> <span class="nv">the</span> <span class="nv">first</span> <span class="nv">node</span><span class="o">,</span> <span class="nv">raw</span><span class="err">.</span>
				<span class="nv">return</span> <span class="nv">expr.length</span> <span class="o">&gt;</span> <span class="m">1</span> <span class="err">?</span> <span class="o">[</span> <span class="s1">&#39;CONCAT&#39;</span> <span class="o">]</span><span class="nv">.concat</span><span class="o">(</span> <span class="nv">expr</span> <span class="o">)</span> <span class="o">:</span> <span class="nv">expr</span><span class="o">[</span> <span class="m">0</span> <span class="o">]</span><span class="err">;</span>
			<span class="o">}</span>

			<span class="nv">function</span> <span class="nv">templateWithReplacement</span><span class="o">()</span> <span class="o">{</span>
				<span class="nv">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="nv">sequence</span><span class="o">(</span> <span class="o">[</span> <span class="nv">templateName</span><span class="o">,</span> <span class="nv">colon</span><span class="o">,</span> <span class="nv">replacement</span> <span class="o">]</span> <span class="o">)</span><span class="err">;</span>

				<span class="nv">return</span> <span class="nv">result</span> <span class="o">===</span> <span class="nv">null</span> <span class="err">?</span> <span class="nv">null</span> <span class="o">:</span> <span class="o">[</span> <span class="nv">result</span><span class="o">[</span> <span class="m">0</span> <span class="o">],</span> <span class="nv">result</span><span class="o">[</span> <span class="m">2</span> <span class="o">]</span> <span class="o">]</span><span class="err">;</span>
			<span class="o">}</span>

			<span class="nv">function</span> <span class="nv">templateWithOutReplacement</span><span class="o">()</span> <span class="o">{</span>
				<span class="nv">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="nv">sequence</span><span class="o">(</span> <span class="o">[</span> <span class="nv">templateName</span><span class="o">,</span> <span class="nv">colon</span><span class="o">,</span> <span class="nv">paramExpression</span> <span class="o">]</span> <span class="o">)</span><span class="err">;</span>

				<span class="nv">return</span> <span class="nv">result</span> <span class="o">===</span> <span class="nv">null</span> <span class="err">?</span> <span class="nv">null</span> <span class="o">:</span> <span class="o">[</span> <span class="nv">result</span><span class="o">[</span> <span class="m">0</span> <span class="o">],</span> <span class="nv">result</span><span class="o">[</span> <span class="m">2</span> <span class="o">]</span> <span class="o">]</span><span class="err">;</span>
			<span class="o">}</span>

			<span class="nv">templateContents</span> <span class="o">=</span> <span class="nv">choice</span><span class="o">(</span> <span class="o">[</span>
				<span class="nv">function</span> <span class="o">()</span> <span class="o">{</span>
					<span class="nv">var</span> <span class="nv">res</span> <span class="o">=</span> <span class="nv">sequence</span><span class="o">(</span> <span class="o">[</span>
						<span class="o">//</span> <span class="nv">templates</span> <span class="nv">can</span> <span class="nv">have</span> <span class="nv">placeholders</span> <span class="nv">for</span> <span class="nv">dynamic</span>
						<span class="o">//</span> <span class="nv">replacement</span> <span class="nv">eg</span><span class="o">:</span> <span class="o">{{</span><span class="nv">PLURAL</span><span class="o">:</span><span class="err">$</span><span class="m">1</span><span class="o">|</span><span class="nf">one</span> <span class="nv">car</span><span class="err">|$</span><span class="m">1</span> <span class="nv">cars</span><span class="cp">}}</span><span class="s1"></span>
<span class="s1">						// or no placeholders eg:</span>
<span class="s1">						// </span><span class="cp">{{</span><span class="nv">GRAMMAR</span><span class="o">:</span><span class="nv">genitive</span><span class="err">|</span><span class="o">{{</span><span class="nv">SITENAME</span><span class="cp">}}</span><span class="s1">}</span>
<span class="s1">						choice( [ templateWithReplacement, templateWithOutReplacement ] ),</span>
<span class="s1">						nOrMore( 0, templateParam )</span>
<span class="s1">					] );</span>

<span class="s1">					return res === null ? null : res[ 0 ].concat( res[ 1 ] );</span>
<span class="s1">				},</span>
<span class="s1">				function () {</span>
<span class="s1">					var res = sequence( [ templateName, nOrMore( 0, templateParam ) ] );</span>

<span class="s1">					if ( res === null ) {</span>
<span class="s1">						return null;</span>
<span class="s1">					}</span>

<span class="s1">					return [ res[ 0 ] ].concat( res[ 1 ] );</span>
<span class="s1">				}</span>
<span class="s1">			] );</span>

<span class="s1">			openTemplate = makeStringParser( &#39;</span><span class="cp">{{</span><span class="s1">&#39; );</span>
<span class="s1">			closeTemplate = makeStringParser( &#39;</span><span class="cp">}}</span><span class="s1">&#39; );</span>

<span class="s1">			function template() {</span>
<span class="s1">				var result = sequence( [ openTemplate, templateContents, closeTemplate ] );</span>

<span class="s1">				return result === null ? null : result[ 1 ];</span>
<span class="s1">			}</span>

<span class="s1">			expression = choice( [ template, replacement, literal ] );</span>
<span class="s1">			paramExpression = choice( [ template, replacement, literalWithoutBar ] );</span>

<span class="s1">			function start() {</span>
<span class="s1">				var result = nOrMore( 0, expression )();</span>

<span class="s1">				if ( result === null ) {</span>
<span class="s1">					return null;</span>
<span class="s1">				}</span>

<span class="s1">				return [ &#39;</span><span class="nx">CONCAT</span><span class="s1">&#39; ].concat( result );</span>
<span class="s1">			}</span>

<span class="s1">			result = start();</span>

<span class="s1">			/*</span>
<span class="s1">			 * For success, the pos must have gotten to the end of the input</span>
<span class="s1">			 * and returned a non-null.</span>
<span class="s1">			 * n.b. This is part of language infrastructure, so we do not throw an</span>
<span class="s1">			 * internationalizable message.</span>
<span class="s1">			 */</span>
<span class="s1">			if ( result === null || pos !== message.length ) {</span>
<span class="s1">				throw new Error( &#39;</span><span class="nx">Parse</span> <span class="nx">error</span> <span class="nx">at</span> <span class="nx">position</span> <span class="s1">&#39; + pos.toString() + &#39;</span> <span class="k">in</span> <span class="nx">input</span><span class="o">:</span> <span class="err">&#39;</span> <span class="o">+</span> <span class="nx">message</span> <span class="p">);</span>
			<span class="p">}</span>

			<span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">};</span>

	<span class="nx">$</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span> <span class="nx">$</span><span class="p">.</span><span class="nx">i18n</span><span class="p">.</span><span class="nx">parser</span><span class="p">,</span> <span class="k">new</span> <span class="nx">MessageParser</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}(</span> <span class="nx">jQuery</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>
</body>
</html>
